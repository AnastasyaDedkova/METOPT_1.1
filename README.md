Дедкова Анастасия Викторовна МЕТОПТ 1.1
# Задание 1
# Решение задач линейного программирования

## Задание

Разработать программу, которая будет решать ЗЛП. На вход дается текстовый файл с общей ЗЛП (формат придумываете сами). На выходе либо информации о существовании решения: оно существует, оптимальное значение целевой функции, вектор x, при котором данное решение достигается. Либо информация о том, что решения нет (либо критерий уходит в минус бесконечность, либо множество X - область допустимых решений - пусто. Использование библиотек для решения оптимизационных задач недопустимо. Но допускается использования библиотек для работы с массивами. В функционале должно предусматриваться: преобразование в канонический вид, определение опорного решения (в том числе через вспомогательную задачу, если возможно), решение основной задачи.

Реализация **не использует сторонние библиотеки оптимизации**, но допускает использование библиотек для работы с массивами (`numpy` и др.).

Демонстрация работы: 

https://disk.yandex.ru/i/k-xqXAdMIYyWGg
![](https://github.com/AnastasyaDedkova/METOPT_1.1/blob/main/Task1/Task1_1.png)

Бонус - подкаст (звукозапись до 1,5 минут с впечатлениями о выполнении работы - как в рефлективном заключении):

https://disk.yandex.ru/d/GlFf8ViWPVt4cw

## Возможности

Программа:

* Принимает ЗЛП из текстового файла в одном из двух форматов:

  * **math-формат** (максимизация/минимизация + ограничения в алгебраическом виде)
  * **табличный формат**
* Автоматически:

  * Приводит задачу к каноническому виду
  * Строит вспомогательную задачу (фаза I)
  * Решает основную задачу (фаза II)
* Выводит:

  * Оптимальное значение целевой функции и значения переменных
  * Либо сообщение:
  * * `UNBOUNDED` - Значение целевой функции можно увеличивать (или уменьшать) бесконечно, не нарушая ограничений. Файл `1problem_unbounded.txt` иллюстрирует это.
  * * `INFEASIBLE` Нет ни одного набора переменных, который удовлетворяет всем ограничениям одновременно. Файл `1problem_infeasible.txt` иллюстрирует это.

## Псевдокод

```txt
ФУНКЦИЯ `main(filepath)`
 данные ← parse_lp(filepath)
 (sense, c, A, b, rels, var_signs) ← данные
 
 стандартная_форма ← to_standard(sense, c, A, b, rels, var_signs)
 (status, value, x) ← simplex(стандартная_форма)
 
 ЕСЛИ status == OPTIMAL:
  вывод "F = value"
  вывод "x1 = ..., x2 = ..., ..."
 ИНАЧЕ ЕСЛИ status == UNBOUNDED:
  вывод "UNBOUNDED"
 ИНАЧЕ:
  вывод "INFEASIBLE"


ФУНКЦИЯ `to_standard(sense, c, A, b, rels, var_signs)`
 ЕСЛИ есть свободные переменные:
  для каждой x_j с пометкой 'free':
   заменить x_j → x_j⁺ − x_j⁻
   обновить A, c, переменные
 
 ЕСЛИ sense == MIN:
  домножить c на −1
 
 ДЛЯ каждой строки i:
  ЕСЛИ b[i] < 0:
   умножить A[i], b[i] на −1
   инвертировать знак ограничения
 
 ДЛЯ каждой строки:
  ЕСЛИ ограничение ≤:
   добавить slack-переменную (в базис)
  ЕСЛИ ограничение ≥:
   добавить surplus и искусственную переменную (в базис — только искусственная)
  ЕСЛИ ограничение =:
   добавить искусственную переменную (в базис)
 
 вернуть StandardLP(c, A, b, базис, типы_переменных, is_min)


ФУНКЦИЯ `simplex(std)`
 Построить таблицу T (Phase I)
 Целевая функция: min сумма искусственных переменных
 (status, _, _) ← simplex_core(T, базис)
 
 ЕСЛИ сумма искусственных переменных ≠ 0:
  вернуть INFEASIBLE
 
 Удалить искусственные переменные
 Построить таблицу T2 (Phase II)
 Задать исходную целевую функцию
 (status, value, x) ← simplex_core(T2, базис)
 
 ЕСЛИ status == OPTIMAL:
  вернуть (OPTIMAL, value, x)
 ИНАЧЕ:
  вернуть UNBOUNDED


ФУНКЦИЯ `simplex_core(T, базис)`
 ПОКА в целевой строке есть положительные коэффициенты:
  выбрать ведущий столбец (по правилу Бланда)
  выбрать ведущую строку (по минимальному положительному отношению b[i] / a[i,j])
  ЕСЛИ нет допустимой строки:
   вернуть UNBOUNDED
  выполнить pivot (обновить таблицу T и базис)
 
 вернуть (OPTIMAL, значение функции, вектор x)

```
## Схема
<img src="https://github.com/AnastasyaDedkova/METOPT_1.1/blob/main/Task1/Task1.png" alt="Схема" width="500" height="1101"/>

## Пример входного файла problem.txt (math-формат)

```txt
min 2x1 + 3x2 + x3 + 4x4
x1 + 2x2 + x3 <= 7
x2 + x3 + x4 = 5
x1 + x4 >= 3
x >= 0
```

## Пример запуска

```bash
python lp_solver.py problem.txt
```

### Ответ

```
F = 11.5
x1 = 2.5 x2 = 0 x3 = 4.5 x4 = 0.5     
```


---

## Формат входного файла

Поддерживаются два формата:

### 1. Math-формат

* Первая строка: `max` или `min` и выражение целевой функции.
* Далее: ограничения в виде линейных неравенств или равенств.
* Поддерживаются комментарии (`#`).
* Поддержка `x >= 0`.

**Пример problem.txt:**

```txt
min 2x1 + 3x2 + x3 + 4x4
x1 + 2x2 + x3 <= 7
x2 + x3 + x4 = 5
x1 + x4 >= 3
x >= 0
```

### 2. Табличный формат

```
MIN
3 4
2 3 1 4
1 2 1 0 <= 7
0 1 1 1 = 5
1 0 0 1 >= 3
```

* Строка 1: `MAX` или `MIN`
* Строка 2: количество ограничений и переменных
* Строка 3: коэффициенты целевой функции
* Далее: по одному ограничению на строку

---

## Тестирование

Для тестирования используется `pytest`.

### Запуск всех тестов:

```bash
python run_tests.py
```

Тесты покрывают:

* Парсинг входных данных
* Приведение к каноническому виду
* Обработку всех статусов (`OPTIMAL`, `UNBOUNDED`, `INFEASIBLE`)
* Корректность вывода
* Масштабируемость (до 200 переменных)

---

## Структура проекта

```text
.
├── lp_solver.py            # Основной решатель
├── test_simplex_solver.py  # Набор юнит-тестов на pytest
├── run_tests.py            # Скрипт для запуска всех тестов
└── problem.txt             # Пример входного файла
```

---

## Ограничения

* Решатель поддерживает только задачи в линейной форме

## Вывод

В ходе выполнения данного задания была разработана программа для решения задач линейного программирования методом двухфазного симплекс-метода без использования внешних библиотек оптимизации.

В процессе реализации удалось:

глубже понять принцип работы симплекс-метода, включая этапы выбора опорного решения, построение базиса и переходов между вершинами допустимой области;

изучить особенности приведения задачи к каноническому виду;

реализовать поддержку двухфазного подхода, позволяющего решать задачи с равенствами и ≥-ограничениями;

научиться различать и обрабатывать типовые ситуации ЗЛП: наличие оптимального решения, отсутствие допустимых решений (INFEASIBLE) и неограниченность целевой функции (UNBOUNDED);

построить систему автоматических тестов, проверяющих корректность парсинга, преобразования, статуса задачи и результата.

Работа была полезна тем, что позволила не просто использовать готовые инструменты, а вникнуть в механизмы линейной оптимизации. Это развивает алгоритмическое мышление, точность в работе с матрицами и системами ограничений, а также навыки отладки и тестирования численных алгоритмов.

