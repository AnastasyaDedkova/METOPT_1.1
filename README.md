Дедкова Анастасия Викторовна МЕТОПТ 1.1
# Задание 1
# Решение задач линейного программирования

## Задание

Разработать программу, которая будет решать ЗЛП. На вход дается текстовый файл с общей ЗЛП (формат придумываете сами). На выходе либо информации о существовании решения: оно существует, оптимальное значение целевой функции, вектор x, при котором данное решение достигается. Либо информация о том, что решения нет (либо критерий уходит в минус бесконечность, либо множество X - область допустимых решений - пусто. Использование библиотек для решения оптимизационных задач недопустимо. Но допускается использования библиотек для работы с массивами. В функционале должно предусматриваться: преобразование в канонический вид, определение опорного решения (в том числе через вспомогательную задачу, если возможно), решение основной задачи.

Реализация **не использует сторонние библиотеки оптимизации**, но допускает использование библиотек для работы с массивами (`numpy` и др.).
Демонстрация работы https://disk.yandex.ru/i/k-xqXAdMIYyWGg


## Возможности

Программа:

* Принимает ЗЛП из текстового файла в одном из двух форматов:

  * **math-формат** (максимизация/минимизация + ограничения в алгебраическом виде)
  * **табличный формат**
* Автоматически:

  * Приводит задачу к каноническому виду
  * Строит вспомогательную задачу (фаза I)
  * Решает основную задачу (фаза II)
* Выводит:

  * Оптимальное значение целевой функции и значения переменных
  * Либо сообщение:
  * * `UNBOUNDED` - Значение целевой функции можно увеличивать (или уменьшать) бесконечно, не нарушая ограничений. Файл `1problem_unbounded.txt` иллюстрирует это.
  * * `INFEASIBLE` Нет ни одного набора переменных, который удовлетворяет всем ограничениям одновременно. Файл `1problem_infeasible.txt` иллюстрирует это.

## Псевдокод

```txt
ФУНКЦИЯ main(filepath):
    данные ← parse_lp(filepath)
    (sense, c, A, b, rels, var_signs) ← данные

    стандартная_форма ← to_standard(sense, c, A, b, rels, var_signs)
    (status, value, x) ← simplex(стандартная_форма)

    ЕСЛИ status == OPTIMAL:
        вывод "F = value"
        вывод "x1 = ..., x2 = ..., ..."
    ИНАЧЕ ЕСЛИ status == UNBOUNDED:
        вывод "UNBOUNDED"
    ИНАЧЕ:
        вывод "INFEASIBLE"

---

ФУНКЦИЯ to_standard(sense, c, A, b, rels, var_signs):
    ЕСЛИ есть свободные переменные:
        для каждой свободной x_j:
            заменить x_j → x_j⁺ − x_j⁻
            обновить A, c, переменные

    ЕСЛИ sense == MIN:
        домножить c на −1

    для каждой строки i:
        ЕСЛИ b[i] < 0:
            инвертировать строку и знак ограничения

    для каждой строки:
        в зависимости от знака:
            добавить slack/surplus/artificial переменные
            записать, какие переменные входят в базис

    вернуть StandardLP(c, A, b, базис, типы_переменных, is_min)

---

ФУНКЦИЯ simplex(std):
    создать симплекс-таблицу T на основе std (Phase I)
    задать целевую функцию: min сумма искусственных переменных

    результат ← simplex_core(T, базис)

    ЕСЛИ сумма искусственных переменных ≠ 0:
        вернуть INFEASIBLE

    удалить искусственные переменные из системы
    построить новую таблицу T2 для Phase II
    задать целевую функцию из изначальной задачи

    результат ← simplex_core(T2, базис)

    ЕСЛИ статус OPTIMAL:
        вернуть (OPTIMAL, значение функции, вектор x)
    ИНАЧЕ:
        вернуть UNBOUNDED

---

ФУНКЦИЯ simplex_core(T, базис):
    ПОКА есть положительные коэффициенты в целевой строке:
        выбрать ведущий столбец (по правилу Бланда)
        выбрать ведущую строку (по минимальному отношению)
        ЕСЛИ нет допустимых строк:
            вернуть UNBOUNDED
        выполнить pivot
    вернуть OPTIMAL

```
## Схема

!

## Пример входного файла problem.txt (math-формат)

```txt
min 2x1 + 3x2 + x3 + 4x4
x1 + 2x2 + x3 <= 7
x2 + x3 + x4 = 5
x1 + x4 >= 3
x >= 0
```

## Пример запуска

```bash
python lp_solver.py problem.txt
```

### Ответ

```
F = 11.5
x1 = 2.5 x2 = 0 x3 = 4.5 x4 = 0.5     
```


---

## Формат входного файла

Поддерживаются два формата:

### 1. Math-формат

* Первая строка: `max` или `min` и выражение целевой функции.
* Далее: ограничения в виде линейных неравенств или равенств.
* Поддерживаются комментарии (`#`).
* Поддержка `x >= 0`.

**Пример problem.txt:**

```txt
min 2x1 + 3x2 + x3 + 4x4
x1 + 2x2 + x3 <= 7
x2 + x3 + x4 = 5
x1 + x4 >= 3
x >= 0
```

### 2. Табличный формат

```
MIN
3 4
2 3 1 4
1 2 1 0 <= 7
0 1 1 1 = 5
1 0 0 1 >= 3
```

* Строка 1: `MAX` или `MIN`
* Строка 2: количество ограничений и переменных
* Строка 3: коэффициенты целевой функции
* Далее: по одному ограничению на строку

---

## Тестирование

Для тестирования используется `pytest`.

### Запуск всех тестов:

```bash
python run_tests.py
```

Тесты покрывают:

* Парсинг входных данных
* Приведение к каноническому виду
* Обработку всех статусов (`OPTIMAL`, `UNBOUNDED`, `INFEASIBLE`)
* Корректность вывода
* Масштабируемость (до 200 переменных)

---

## Структура проекта

```text
.
├── lp_solver.py            # Основной решатель
├── test_simplex_solver.py  # Набор юнит-тестов на pytest
├── run_tests.py            # Скрипт для запуска всех тестов
└── problem.txt             # Пример входного файла
```

---

## Ограничения

* Решатель поддерживает только задачи в линейной форме
* Все переменные предполагаются неотрицательными (`x >= 0`)

